package tf.bug.hexstudio.antimirov

/**
 * Extended integer representation of sizes.
 *
 * This class is used to represent the lengths of matched strings.
 * Unbounded values are generated by things like the Kleene star
 * operator.
 *
 * Size supports addition and multiplication. Additionally, Size has a
 * total ordering (unbounded values are considered), so comparisons
 * are also supported.
 *
 * Sizes are required to be non-negative, i.e. 0 <= size < ∞.
 */
sealed abstract class Size { lhs =>

  import Size.{Small, Big, Unbounded}

  def isFinite: Boolean

  def +(rhs: Size): Size

  def *(rhs: Size): Size

  def pow(k: Int): Size = {
    def loop(i: Int, acc: Size, mult: Size): Size = {
      if (i <= 0) Size.One
      else if (i == 1) mult * acc
      else loop(i / 2, if (i % 2 == 1) acc * mult else acc, mult * mult)
    }
    loop(k, Size.One, this)
  }

  /**
   * Show approximate as well as actual size as a string.
   *
   * For unbounded or small sizes, this method is identical to
   * toString.
   *
   * For finite sizes a million or larger, this method will return
   * scientific notation to approximate the number followed by the
   * full decimal representation in parenthesis.
   *
   *   Size(0).approxString               // 0
   *   Size(123456).approxString          // 123456
   *   Size(1234567).approxString         // 1.23 x 10^6 (1234567)
   *   Size(1234567).pow(3).approxString  // 1.88 x 10^18 (1881672302290562263)
   *   Size.Unbounded.approxString        // ∞
   */
  def approxString: String = {
    def approx(num: BigInt): String =
      if (num < 1000000) {
        num.toString
      } else {
        // TODO: calculate log10 to do this more efficiently
        var n = num
        var k = 0
        // make sure n won't round up to 1000 once we exit the loop
        while (n >= 9994) {
          n /= 10
          k += 1
        }
        // round the final digit
        n = (n + 5) / 10 // n in [0, 999]
        k += 1 // k in [6, ∞)
        val s = n.toString
        val d = s.charAt(0)
        val ds = s.substring(1, 3)
        s"$d.$ds x 10^${k + 2} ($this)"
      }

    this match {
      case Unbounded => "∞"
      case Small(n) => approx(BigInt(n))
      case Big(n) => approx(n)
    }
  }

  def <(rhs: Size): Boolean = compare(rhs) < 0
  def <=(rhs: Size): Boolean = compare(rhs) <= 0
  def >(rhs: Size): Boolean = compare(rhs) > 0
  def >=(rhs: Size): Boolean = compare(rhs) >= 0

  def min(rhs: Size): Size =
    if (lhs <= rhs) lhs else rhs

  def max(rhs: Size): Size =
    if (lhs >= rhs) lhs else rhs

  def compare(size: Size): Int
}

object Size {

  val Zero: Size = Size(0L)
  val One: Size = Size(1L)

  def apply(n: Int): Size = {
    require(n >= 0)
    Small(n.toLong)
  }

  def apply(n: Long): Size = {
    require(n >= 0L)
    Small(n)
  }

  def apply(n: BigInt): Size = {
    require(n.signum >= 0)
    if (n.isValidLong) Small(n.toLong) else Big(n)
  }

  // for Small(n) we require 0 <= n.
  final case class Small private[antimirov] (n: Long) extends Size {
    override def isFinite: Boolean = true

    override def +(rhs: Size): Size = rhs match {
      case Unbounded => Unbounded
      case Small(y) =>
        val z = n + y
        if (z >= 0) Small(z) else Big(BigInt(n) + BigInt(y))
      case Big(y) =>
        Big(BigInt(n) + y)
    }

    override def *(rhs: Size): Size =
      if(n == 0L) Zero
      else if(n == 1L) rhs
      else rhs match {
        case Zero => Zero
        case Unbounded => Unbounded
        case Small(y) =>
          val z = n * y
          if ((z / n) == y) Small(z) else Big(BigInt(n) * BigInt(y))
        case Big(y) =>
          Big(BigInt(n) * y)
      }

    override def toString: String = n.toString

    override def compare(rhs: Size): Int = rhs match {
      case Small(y) => java.lang.Long.compare(n, y)
      case _ => -1
    }
  }

  // for Big(n) we require Long.MaxValue < n.
  final case class Big private[antimirov] (n: BigInt) extends Size {
    override def isFinite: Boolean = true

    override def +(rhs: Size): Size = rhs match {
      case Unbounded => Unbounded
      case Small(y) => Big(n + BigInt(y))
      case Big(y) => Big(n + y)
    }

    override def *(rhs: Size): Size = rhs match {
      case Zero => Zero
      case Unbounded => Unbounded
      case Small(y) => Big(n * BigInt(y))
      case Big(y) => Big(n * y)
    }

    override def toString: String = n.toString

    override def compare(rhs: Size): Int = rhs match {
      case Unbounded => -1
      case Big(y) => n.compare(y)
      case Small(_) => 1
    }
  }

  case object Unbounded extends Size {
    override def isFinite: Boolean = false

    override def +(rhs: Size): Size = Unbounded

    override def *(rhs: Size): Size = Unbounded

    override def toString: String = "∞"

    override def compare(rhs: Size): Int =
      if(rhs == Unbounded) 0 else 1
  }
}
